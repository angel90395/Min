<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>皮克敏種花收果路徑產生器</title></title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { display: flex; flex-direction: column; font-family: -apple-system, sans-serif; background: #f0f2f5; }

        /* 控制面板：手機版固定佔比，支援捲動 */
        #controls { 
            width: 100%; max-height: 45vh; padding: 15px; background: white; 
            z-index: 2000; box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
            overflow-y: auto; flex-shrink: 0; transition: 0.3s;
        }
        
        /* 地圖：強制撐開高度 */
        #map { flex: 1; min-height: 50vh; width: 100%; z-index: 1; background: #e5e5e5; }

        /* 全螢幕切換 */
        body.is-fullscreen #controls { max-height: 0; padding: 0; border: none; }
        body.is-fullscreen #map { height: 100vh; min-height: 100vh; }

        .card { background: #fff; padding: 10px; border-radius: 8px; margin-bottom: 10px; border: 1px solid #ddd; border-left: 5px solid #27ae60; }
        textarea { width: 100%; height: 50px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px; padding: 8px; }
        select, button { width: 100%; padding: 12px; margin: 4px 0; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; }
        
        .btn-gen { background: #27ae60; color: white; }
        .btn-screen { background: #34495e; color: white; }
        .btn-download { background: #007bff; color: white; display: none; }
        
        #floatingBtn { position: fixed; top: 10px; right: 10px; z-index: 3000; background: rgba(0,0,0,0.7); color: white; border: none; padding: 12px; border-radius: 8px; display: none; }
        body.is-fullscreen #floatingBtn { display: block; }
        .hidden { display: none; }
        #status { font-size: 12px; color: #666; text-align: center; margin-top: 5px; }

        @media (min-width: 768px) {
            body { flex-direction: row; }
            #controls { width: 380px; height: 100vh; max-height: 100vh; border-right: 1px solid #ddd; }
            body.is-fullscreen #controls { width: 0; }
        }
    </style>
</head>
<body id="mainBody">

<button id="floatingBtn" onclick="toggleMapMode()">恢復控制面板</button>

<div id="controls">
    <button class="btn-screen" onclick="toggleMapMode()">地圖全頻切換</button>

    <div class="card">
        <label><b>1. 路線模式</b></label>
        <select id="pathMode">
            <option value="linear">座標串接（適合收果或多帳種花）</option>
            <option value="z-shape">Z字路線 (2圈、適合種藍)</option>
            <option value="square">正方形路線 (2圈、適合種白)</option>
        </select>
    </div>

    <div class="card" style="border-left-color: #f1c40f;">
        <label><b>2. 輸入來源</b></label>
        <select id="sourceType" onchange="toggleSource()">
            <option value="manual">手動貼上座標</option>
            <option value="file">上傳 GPX 檔案</option>
        </select>
    </div>

    <div id="manualSection" class="card">
        <textarea id="coordInput" placeholder="緯度, 經度 (每行一組)"></textarea>
    </div>

    <div id="fileSection" class="card hidden" style="border-left-color: #f1c40f;">
        <input type="file" id="gpxFile" accept=".gpx,.xml" style="width: 100%;">
    </div>

    <button class="btn-gen" onclick="handleGenerate()">產生路徑並預覽</button>
    <button id="downloadBtn" class="btn-download" onclick="exportGPX()">下載 GPX</button>
    <div id="status">地圖已就緒</div>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<script>
    // --- 強化初始化 ---
    var map;
    function initMap() {
        if (map) return;
        try {
            map = L.map('map', { zoomControl: false }).setView([23.5, 121], 7);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
            L.control.zoom({ position: 'bottomright' }).addTo(map);
        } catch(e) {
            document.getElementById('status').innerText = "地圖載入失敗，請檢查網路。";
        }
    }
    window.onload = initMap;

    var pathLayer, markerLayer, finalPoints = [];

    function toggleMapMode() {
        document.getElementById('mainBody').classList.toggle('is-fullscreen');
        setTimeout(() => { if(map) map.invalidateSize(); }, 400);
    }

    function toggleSource() {
        const type = document.getElementById('sourceType').value;
        document.getElementById('manualSection').classList.toggle('hidden', type !== 'manual');
        document.getElementById('fileSection').classList.toggle('hidden', type === 'manual');
    }

    async function handleGenerate() {
        const status = document.getElementById('status');
        const sourceType = document.getElementById('sourceType').value;
        const mode = document.getElementById('pathMode').value;
        status.innerText = "運算中...";

        try {
            let centers = [];
            if (sourceType === 'manual') {
                const txt = document.getElementById('coordInput').value.trim();
                if (!txt) throw new Error("請輸入座標");
                txt.split('\n').forEach(l => {
                    const p = l.split(/[ ,]+/).filter(x => x);
                    if (p.length >= 2) centers.push([parseFloat(p[1]), parseFloat(p[0])]);
                });
                centers = solveUnknottedCycle(centers); // 白色線條解結邏輯
            } else {
                const fileInput = document.getElementById('gpxFile');
                if (fileInput.files.length === 0) throw new Error("請選取檔案");
                const xml = await fileInput.files[0].text();
                [span_0](start_span)// 讀取包含 rtept 的 GPX 檔案[span_0](end_span)
                const regex = /lat=["']([\d.-]+)["']\s+lon=["']([\d.-]+)["']/g;
                let m; while ((m = regex.exec(xml)) !== null) centers.push([parseFloat(m[2]), parseFloat(m[1])]);
                fileInput.value = ""; // 清除檔案欄位，重新開始
            }

            if (centers.length === 0) throw new Error("無有效座標");
            centers = centers.filter((v, i, a) => a.findIndex(t => t[0] === v[0] && t[1] === v[1]) === i);

            finalPoints = buildAdaptivePath(centers, mode);

            if (pathLayer) map.removeLayer(pathLayer);
            if (markerLayer) map.removeLayer(markerLayer);

            pathLayer = L.polyline(finalPoints.map(p => [p[1], p[0]]), {color: '#007bff', weight: 4}).addTo(map);
            markerLayer = L.featureGroup(centers.map(c => L.circleMarker([c[1], c[0]], {radius: 4, color: 'red', fillOpacity:1}))).addTo(map);
            
            map.fitBounds(pathLayer.getBounds(), {padding: [50, 50]});
            status.innerText = "完成！軌跡已閉合且不交叉。";
            document.getElementById('downloadBtn').style.display = 'block';
        } catch (e) { status.innerText = "錯誤: " + e.message; }
    }

    // --- 2-Opt 解結：產生像您畫的「白色線條」那種不交叉的環 ---
    function solveUnknottedCycle(pts) {
        if (pts.length < 3) return pts;
        let route = [...pts];
        const center = turf.center(turf.featureCollection(route.map(p => turf.point(p)))).geometry.coordinates;
        route.sort((a, b) => Math.atan2(a[1]-center[1], a[0]-center[0]) - Math.atan2(b[1]-center[1], b[0]-center[0]));

        let improved = true;
        while (improved) {
            improved = false;
            for (let i = 0; i < route.length - 1; i++) {
                for (let j = i + 2; j < route.length; j++) {
                    const dCurrent = dist(route[i], route[i+1]) + dist(route[j], route[(j+1)%route.length]);
                    const dNew = dist(route[i], route[j]) + dist(route[i+1], route[(j+1)%route.length]);
                    if (dNew < dCurrent) {
                        let sub = route.slice(i + 1, j + 1);
                        route.splice(i + 1, j - i, ...sub.reverse());
                        improved = true;
                    }
                }
            }
        }
        return route;
    }

    function dist(p1, p2) { return turf.distance(turf.point(p1), turf.point(p2)); }

    // --- 動態 Z 字/正方形生成 ---
    function buildAdaptivePath(centers, mode) {
        let path = []; const r = 41;
        for (let i = 0; i < centers.length; i++) {
            const curr = centers[i];
            if (mode === 'linear') { path.push(curr); continue; }

            const prev = centers[i === 0 ? centers.length - 1 : i - 1];
            const next = centers[(i + 1) % centers.length];
            const bearing = turf.bearing(turf.point(prev), turf.point(next));
            
            const v = {
                a: turf.destination(turf.point(curr), r, bearing - 135, {units:'meters'}).geometry.coordinates,
                b: turf.destination(turf.point(curr), r, bearing - 45, {units:'meters'}).geometry.coordinates,
                c: turf.destination(turf.point(curr), r, bearing + 45, {units:'meters'}).geometry.coordinates,
                d: turf.destination(turf.point(curr), r, bearing + 135, {units:'meters'}).geometry.coordinates
            };

            let group = (mode === 'z-shape') ? [v.a, v.b, curr, v.d, v.c] : [v.a, v.b, v.c, v.d, v.a];

            if (path.length > 0) {
                const last = path[path.length - 1];
                if (dist(last, group[group.length-1]) < dist(last, group[0])) group.reverse();
            }
            path.push(...group);
        }
        if (path.length > 0) {
            path = path.filter((v, i, a) => i === 0 || !(v[0] === a[i-1][0] && v[1] === a[i-1][1])); // 去除重複線段
            path.push(path[0]); // 封閉式
        }
        return path;
    }

    function exportGPX() {
        let gpx = `<?xml version="1.0" encoding="UTF-8"?><gpx version="1.1"><trk><trkseg>`;
        finalPoints.forEach(pt => gpx += `\n<trkpt lat="${pt[1].toFixed(8)}" lon="${pt[0].toFixed(8)}"></trkpt>`);
        gpx += `\n</trkseg></trk></gpx>`;
        const blob = new Blob([gpx], { type: 'application/gpx+xml' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
        a.download = `optimized_path_${Date.now()}.gpx`; a.click();
    }
</script>
</body>
</html>
